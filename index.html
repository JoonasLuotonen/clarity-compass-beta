<!doctype html>
<html lang="en">
<script>
  const scope = document.getElementById('scope');
  const context = document.getElementById('context');
  const urlInput = document.getElementById('url');
  const shots = document.getElementById('shots');
  const out = document.getElementById('out');
  const runBtn = document.getElementById('run');
  const demoBtn = document.getElementById('demo');

  demoBtn.onclick = () => { urlInput.value = 'https://example.com'; scope.value = 'Homepage'; };

  runBtn.onclick = async () => {
    try {
      const cm = await getClientMetrics(shots.files);
      const payload = {
        url: urlInput.value.trim(),
        context: context.value,
        scopeLabel: scope.value.trim(),
        clientMetrics: cm
      };

      const r = await fetch('/api/analyze', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      });
      const data = await r.json();

      renderRadar('radar', data.scores);
      document.getElementById('json').textContent = JSON.stringify(data, null, 2);
      out.classList.remove('hidden');
    } catch (err) {
      alert('Something went wrong. Open DevTools → Console to see details.');
      console.error(err);
    }
  };

  // ---- Client-side image heuristics (optional; keeps free tier)
  async function getClientMetrics(fileList){
    const files = Array.from(fileList || []).slice(0,3);
    if(files.length===0) return null;

    const bitmaps = await Promise.all(files.map(f=>createImageBitmap(f)));
    const metrics = bitmaps.map(bm=>analyzeBitmap(bm));

    const avg = (k)=> metrics.reduce((a,m)=>a+m[k],0)/metrics.length;

    const edge = avg('edge');      // more edges = more visual noise
    const colors = avg('colors');  // more unique colors = less consistency
    const bright = avg('bright');  // crude proxy for “light” tone

    return {
      visualConsistency: clamp01(1 - (colors*0.4 + edge*0.6)),
      visualTone: clamp01(bright),
      visualEnvironment: 0.5,                 // placeholder until we add a selector
      storyEmotion: clamp01(0.3 + (1-edge)*0.4),
      storyIdentity: clamp01(0.3 + (1-colors)*0.5)
    };
  }

  function analyzeBitmap(bm){
    const c = new OffscreenCanvas(bm.width, bm.height);
    const ctx = c.getContext('2d');
    const w = 640; const h = Math.round(bm.height * (w/bm.width));
    ctx.drawImage(bm, 0, 0, w, h);
    const img = ctx.getImageData(0, 0, w, h);

    let edges=0, colorsSet=new Set(), total=w*h, brightSum=0;

    for(let i=0;i<img.data.length;i+=4){
      const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
      const y = (0.2126*r+0.7152*g+0.0722*b)/255; // luminance
      brightSum += y;
      colorsSet.add(((r>>4)<<8) | ((g>>4)<<4) | (b>>4)); // reduced palette index

      if(i>4){
        const pr=img.data[i-4], pg=img.data[i-3], pb=img.data[i-2];
        const py=(0.2126*pr+0.7152*pg+0.0722*pb)/255;
        if(Math.abs(y-py)>0.25) edges++;
      }
    }
    return {
      edge: edges/total,
      colors: Math.min(1, colorsSet.size/4096),
      bright: brightSum/total
    };
  }

  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  // ---- Simple radar renderer (canvas)
  function renderRadar(id, scores){
    const cvs = document.getElementById(id);
    const ctx = cvs.getContext('2d');
    const size = cvs.width;
    ctx.clearRect(0,0,size,size);

    const cx = size/2, cy = size/2, R = 160;
    const toRad = a => a*Math.PI/180;

    // grid
    ctx.strokeStyle = 'rgba(255,255,255,.1)';
    for(let r=R/3;r<=R;r+=R/3){ ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke(); }

    const lensAvg = vals => vals.reduce((a,b)=>a+b,0)/vals.length;

    const u = lensAvg(Object.values(scores.user))/5;
    const v = lensAvg(Object.values(scores.visual))/5;
    const s = lensAvg(Object.values(scores.story))/5;

    const points = [
      {a:-90, r:u*R}, {a:30, r:v*R}, {a:150, r:s*R}
    ].map(p=>({ x: cx+Math.cos(toRad(p.a))*p.r, y: cy+Math.sin(toRad(p.a))*p.r }));

    // polygon
    ctx.beginPath(); ctx.moveTo(points[0].x, points[0].y);
    points.slice(1).forEach(p=>ctx.lineTo(p.x,p.y));
    ctx.closePath();
    ctx.fillStyle='rgba(34,197,94,.35)';
    ctx.strokeStyle='rgba(34,197,94,.9)';
    ctx.lineWidth=2;
    ctx.fill(); ctx.stroke();

    // labels
    ctx.fillStyle='#e6e6e6'; ctx.font='14px Inter'; ctx.textAlign='center';
    [[-90,'User'],[30,'Visual'],[150,'Story']].forEach(([a,l])=>{
      ctx.fillText(l, cx+Math.cos(toRad(a))*(R+16), cy+Math.sin(toRad(a))*(R+16));
    });
  }
</script>

</html>
